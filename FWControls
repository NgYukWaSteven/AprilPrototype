#include "Wire.h"
#include "math.h"
#include "I2Cdev.h"

//IMU Dependencies
#include "LSM6DS3.h"
#include "MPU6050.h"

//DShot
#include "DShot.h"

//Create a instance of class LSM6DS3
//This is the embedded IMU on the Seeeduino nrf chip on the abdomen
LSM6DS3 abdomenIMU(I2C_MODE, 0x6A);    //I2C device address 0x6A
MPU6050 bodyIMU;

//Create instance of clss DShot, in dshot600 mode
DShot esc1(DShot::Mode::DSHOT600);

//Throttle and target value for esc
uint16_t throttle = 0;
uint16_t target = 0;

//Pre-allocate IMU raw values for abdomen and body
int16_t axA, ayA, azA;
int16_t gxA, gyA, gzA;

int16_t axB, ayB, azB;
int16_t gxB, gyB, gzB;

//Complimentary Filter Parameters
// Constants
float alpha = 0.98;             // Complementary filter constant
float dt = 0.01;                // Time step (s), adjust to match your sampling rate (e.g., 10ms = 0.01s)

// Variables to store angles
float pitchA = 0.0;
float rollA = 0.0;
float pitchB = 0.0;
float rollB = 0.0;

unsigned long lastTime = 0;

void setup() {
  Serial.begin(115200);
  esc1.attach(7); //Attach esc signal wire to pin 7
  esc1.setThrottle(throttle); //Set throttle (Initially 0)
}

void loop() {
  // Time calculation
  unsigned long currentTime = millis();
  dt = (currentTime - lastTime) / 1000.0;  // convert ms to seconds
  lastTime = currentTime;

  //Get body and abdomen raw values
  bodyIMU.getMotion6(&axB, &ayB, &azB, &gxB, &gyB, &gzB);
  axA = myIMU.readFloatAccelX();
  ayA = myIMU.readFloatAccelY();
  azA = myIMU.readFloatAccelZ();
  gxA = myIMU.readFloatGyroX();
  gyA = myIMU.readFloatGyroY();
  gzA = myIMU.readFloatGyroZ();

  //Complimentary Filter for abdomen and body pitch and roll
  // Calculate pitch and roll from accelerometer
  float accPitchA = atan2(ayA, sqrt(axA * axA + azA * azA)) * 180.0 / PI;
  float accRollA  = atan2(-axA, azA) * 180.0 / PI;
  float accPitchB = atan2(ayB, sqrt(axB * axB + azB * azB)) * 180.0 / PI;
  float accRollB  = atan2(-axB, azB) * 180.0 / PI;

    // Integrate gyro data
  pitchA = alpha * (pitch + gyA * dt) + (1 - alpha) * accPitchA;
  rollA  = alpha * (roll  + gxA * dt) + (1 - alpha) * accRollA;
  pitchB = alpha * (pitch + gyB * dt) + (1 - alpha) * accPitchB;
  rollB = alpha * (roll  + gxB * dt) + (1 - alpha) * accRollB;
}

